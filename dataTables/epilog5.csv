lookupKey	value
feBlend	#' @section feBlend Mode Details:#' feBlend Modes are defned as follows#' #' **normal mode (no blending)**#' #' $$ \alpha_{out} = 1 - (1- \alpha_{in1})  (1- \alpha_{in2}) $$#' $$ \alpha_{out}  \times C_{out} =(1-\alpha_{in2})  \alpha_{in1} C_{in1} + \alpha_{in1}  C_{in1} $$#' #' **multiply blend mode**#' #' $$ \alpha_{out} = 1 - (1- \alpha_{in1}) \times (1- \alpha_{in2)} $$#' $$\alpha_{out}  \times C_{out} = (1-\alpha_{in2})  \alpha_{in1} C_{in1} + (1-\alpha_{in1})  \alpha_{in2} C_{in2} + \alpha_{in1} \alpha_{in2}  C_{in1}   C_{in2} $$#' #' **screen blend mode**#' #' $$ \alpha_{out} = 1 - (1- \alpha_{in1}) \times (1- \alpha_{in2)} $$#' $$ \alpha_{out}  \times C_{out} = \alpha_{in1} C_{in1} + \alpha_{in2} C_{in2} + \alpha_{in1} \alpha_{in2}  C_{in1}   C_{in2} $$#' #' **darken blend mode**#' #' $$ \alpha_{out} = 1 - (1- \alpha_{in1}) \times (1- \alpha_{in2)} $$#' $$\alpha_{out}  \times C_{out} = min( (1-\alpha_{in1})  \alpha_{in2} C_{in2} + \alpha_{in1}C_{in1}, (1-\alpha_{in2})  \alpha_{in1} C_{in1} + \alpha_{in2}C_{in2} )$$#' #' **lighten blend mode**#' #' $$ \alpha_{out} = 1 - (1- \alpha_{in1}) \times (1- \alpha_{in2)}$$#' $$ \alpha_{out}  \times C_{out} = max((1-\alpha_{in1}) \times \alpha_{in2} C_{in2} + \alpha_{in1}C_{in1},(1-\alpha_{in2}) \times \alpha_{in1} C_{in1} + \alpha_{in2}C_{in2})$$#' 
feComponentTransfer	#' @section Component Mapping Algorithm Details:#' The compononet Mappin Algoritms are as follows:#' #' \itemize{#' \item {\strong{identity}:#' \itemize{#'    \item{ To use specify #'       \itemize{#'           \item{type='identity'}#'       }#'    } #'    \item{ Provides no mapping. In terms of color components, for each color component C, we have:#'     \deqn{ C^{out}= C^{in}}#'    } #' }}#' \item{\strong{linear}#'   \itemize{ Specified by#'      \itemize{#'         \item{type='linear'}#'         \item{slope=<NUMERIC>} (default=1)#'         \item{intercept=<NUMERIC>} (default=0)#'      }#'      \item{Maps the colors components using a linear function with the given slope and intercept.#'       In terms of color components #'      \deqn{ C^{out}= m \times C^{in} + b} where \eqn{m} is given by the value of the slope attribute and#'      \eqn{b} is given by the value of the intercept attribute.#'       }#'   }#' }#' \item{\strong{gamma}#'   \itemize{ Specified by#'     \itemize{#'        \item{type='gamma'}#'        \item{exponent=<NUMERIC>} (default=1)#'        \item{amplitude=<NUMERIC>} (default=1)#'        \item{offset=<NUMERIC>} (default=0)#'     }#'   }#'   \item{ Maps the colors components non-linearly using a exponential function#'    In terms of color components #'    \deqn{ C_{out}= A \times C_{in}^B +C} where,  #'    A is given by the \emph{amplitute} attribute, B by the \emph{exponent} attribute and C but the \emph{offset} attribute.#'   }}#' \item {\strong{table}#' \itemize{#'     \item{Specified by#'        \itemize{#'           \item{type='table'}#'           \item{table=<NUMERIC VECTOR>}#'        }#'     }#'     \item Maps the colors components using a continous piece-wise linear function #'       defined by the \emph{valueTable} attribute. In terms of color components and a \emph{valueTable} attribute, v=c(v1,...,vn)#'       for each color component \eqn{C^{in}}, we have:#'       \deqn{C^{out}= v_k + m_k \times (v_{k+1}- v_k)}#'       when \eqn{C^{in}<1} and where \eqn{k} and \eqn{m_k} are given by#'       \deqn{k=floor(C^{in} \times n)}#'       and #'       \deqn{m_k= C^{in} \times n mod(k) }#'       In the case that  \eqn{C^{in}=1}, then we set \eqn{C^out=v_n}#' }}#' \item {\strong{discrete}#' \itemize{#'    \item{Specified by #'        \itemize{#'           \item{type='table'}#'           \item{table=<NUMERIC VECTOR>}#'        }#'     }#'     \item {Maps the colors components using a  step function #'       defined by the \emph{valueTable} attribute. In terms of color components and a \emph{valueTable} attribute, v=c(v1,...,vn)#'       for each color component \eqn{C^{in}}, we have:#'       \deqn{C^{out}= v_k}#'       when \eqn{C^{in}<1} and where k is given by#'       \deqn{k=floor(C^{in} \times n)}#'       In the case that  \eqn{C^{in}=1}, then we set \eqn{C^out=v_n}#'       }#' } }#' }
feCompositeOperator	#'  @section Composite Operator Details: #'  The following defines each *composite operator*. In particular, how the resulting output alpha channel ($\alpha_{out}$) and#'  the resulting color channels $\C_{out}$) are computed from the input channels of *in1* and *in2*.#'  #'  **over operator**#'  $$ \alpha_{out} = \alpha_{in1}  + \alpha_{in2}  (1-\alpha_{in1})  $$#'  $$ \alpha_{out}  \times C_{out}  = \alpha_{in1}  C_{in1} + \alpha_{in2} (1-\alpha_{in1}) C_{in2} $$#'  #'  **in operator**#'  $$ \alpha_{out} = \alpha_{in1}  \alpha_{in2}   $$#'  $$ \alpha_{out}  \times C_{out} = \alpha_{in1}  \alpha_{in2}  C_{in1}  $$#'  #'  **out operator**#'  $$ \alpha_{out} = \alpha_{in1} (1- \alpha_{in2}) )  $$#'  $$ \alpha_{out}  \times C_{out} = \alpha_{in1} (1- \alpha_{in2})  C_{in1}  $$#'  #'  **atop operato**r#'  $$ \alpha_{out} = \alpha_{in1} \alpha_{in2} + (1-\alpha_{in1}) \alpha_{in2}  $$#'  $$ \alpha_{out}  \times C_{out} = \alpha_{in1} \alpha_{in2} C_{in1} + \alpha_{in2} (1-\alpha_{in1}) C_{in2} $$#'  #'  **xor operator**#'  $$ \alpha_{out} = \alpha_{in1} ( 1- \alpha_{in2}) + (1-\alpha_{in1}) \alpha_{in2}  $$#'   $$ \alpha_{out}  \times C_{out} = \alpha_{in1}( 1- \alpha_{in2})  C_{in1} + \alpha_{in2} (1-\alpha_{in1}) C_{in2} $$#'  #'  **arithemetic operator**#'  $$ \alpha_{out} = max(0,min(1,k1 \alpha_{in1} \alpha_{in2} + k2 \alpha_{in1}+ k3 \alpha_{in2} +k4))$$#'  $$ C_{out}= k1  C_{in1}  C_{in2}  +   k2  C_{in1} + k3  C_{in2} + k4 $$#'  
pathData	#' @section Path-Data Details:#' Path-data is a description consisting of a collection of pairs of path commands and values.  #' Path-data is be represented in one of two ways, either as an named list or as a vector.#' In the named list representation, the names are letters-tokens for commands and the corresponding values play the role of the parameters for those commands.#' \code{list(M=c(100,100), L=c(200,200), h=10, Z=NULL)}#' In the vector representation, each name is a letter-token (of class character) followed by the corresponding values, again playing the role of the parameters for those commands. #' \code{c('M', c(100,100), 'L', c(200,200), 'h', 10, 'Z')}#' In the following we write pt for a point c(x,y).#' #' **Path Data Command Table**#' \tabular{lll}{#' Name  \tab Values   \tab    Interpetion \cr#' 'M','m'   \tab pt+   \tab    Move the current point to a new location (without drawing) \cr#' 'L','l'   \tab pt+   \tab    Draw a line from the current point to pt \cr#' 'H','h'   \tab (x)+     \tab    Draw a horizontal line from the current point \cr#' 'V','v'   \tab (y)+     \tab    Draw a vertical line from the current\cr#' 'C','c'   \tab c(pt1,pt2,pt)+  \tab  Draw a cubic Bezier curve to pt with control points pt1,pt2, (x2,y2)\cr#' 'S','s'   \tab c(pt2,pt))+  \tab  Draw a cubic Bezier to pt using pt2 as the second control pt (inheriting the first control point from a preceding Bézier)\cr#' 'Q','q'   \tab c(pt1,pt))+  \tab  Draw a quadratic Bezier to pt using pt1 as the control pt \cr     #' 'T','t'   \tab pt+ \tab Draw a quadratic Bezier curve to pt (inheriting the control from a preceding Bézier)\cr#' 'A','a'  \tab c(rxy, theta, LargeArc, SweepRight, pt) \tab   Draw an arc the current point to the point pt, based on an ellipse of radii rxy, rotated by \eqn{\theta} degrees. \cr#'       \tab                 \tab   Use 1 or 0 for TRUE or FALSE in the LargeArc, SweepRigh flags \cr#' 'Z','z'     \tab \tab Closes the Path#' }#' #' **Note:**#' \itemize{#' \item{Each name is denoted by a single letter}#' \item{Names can be repeated in the list (or vector)}#' \item{Names with upper-case letters indicate the coordinate values are interpreted to be absolute.}#' \item{Names with lower-case letters indicate the coordinate values are interpreted to be relative.}#' \item{Z (or z), the command that closes the path, takes no value in the vector form, and in list form the value is ignored.}#' }   
preserveAspectRatio	"#' @section Details: #' A preserveAspectRatio value is a vector, which consists of mandatory alignment directive, possibly prepended with an optional defer directive and possibly#' postpended with an optional meet-or-slice directive.#' #' **The Align Directives** (mandatory, pick one)#' \tabular{ll}{#' xMinYMin  \tab Place the viewBox in the top-left hand corner of the viewport, and force uniform scaling. \cr#' xMidYMin  \tab Place the viewBox at the top of the viewport and center it horizontally with respect to the viewport, and force uniform scaling. \cr#' xMaxYMin  \tab Place the viewBox at the top-left hand corner of the viewport, and force uniform scaling. \cr#' xMinYMid   \tab Place the viewBox to be centered at the left edge of the viewport, and force uniform scaling. \cr#' xMidYMid   \tab Place the viewBox to be centered at the center of the viewport, and force uniform scaling. This is the default. \cr#' xMaxYMid  \tab Place the viewBox to be centered at the right edge of the viewport, and force uniform scaling. \cr#' xMinYMax  \tab Place the viewBox at the lower-left hand corner of the viewport, and force uniform scaling. \cr#' xMidYMax  \tab Place the viewBox at the center of the bottom edge of the viewport, and force uniform scaling. \cr#' xMaxYMax  \tab Place the viewBox at the lower-lright hand corner of the viewport, and force uniform scaling.\cr#' none  \tab Scale the graphics so that the viewBox coinsides with the viewport and ignore any meet or slice directives. #' }#' (Note: if <align> is none, then the optional <meetOrSlice> value is ignored.)#' #' **The Meet-o-Slice Directives** (optional)#' \tabular{ll}{#' meet \tab Directive to scale up the graphic  as  such that the resulting viewBox is still contained within the viewPort, while still maintaining the original the aspect ratio. \cr#' slice \tab Directive to scale up the graphic as  such that the resulting viewBox just covers the viewPort, while still maintaining the original the aspect ratio. #' }	#' #' **The Defer Directive** (optional):#' \tabular{ll}{#' defer \tab Directive to instruct that any 'peserveAspectRation' value set in the content takes precedence.#' }"
transform	#' @section Details:#' A \strong{transform-list} is named list of coordinate transforms to be applied in the order in which they appear. #' For example:#' \code{ list(translate=c(100,20), scale=1.2, rotate=c(30,100,20))}#' The list names and #' corresponding values (all numeric)#' are summarized in the following table#' **Transforms**#' \tabular{lll}{#' name     \tab value  \tab action \cr#' matrix   \tab  a 2x3 matrix m. \tab Transforms coordinates x,y to x'y' by c(x',y',1)<-m \%*\% c(x,y,1), where m'<-rbind(m,c(0,0,1). \cr#' translate \tab x or c(x,y) \tab Translates by c(x, y). If only x is specified, y is set to 0. \cr#' scale     \tab sx or c(sx, sy) \tab Scales by sx, sy. If only sx is specified, sy=sx. \cr#' rotate    \tab $\theta$ or c( $\theta$,x,y). \tab Rotates by theta degrees about the point c(x,y). If only the  $\theta$ is specified, then x=y=0. \cr#' skewX    \tab $\theta_x$ \tab Skews along the x-axis by an angle of $\theta_x$ , where $\theta_x$ is interpreted in units of degrees.\cr#' skewY    \tab $\theta_y$  \tab Skews along the y-axis by an angle of $\theta_y$ , where $\theta_y$ is interpreted in units of degrees.\cr#' }
